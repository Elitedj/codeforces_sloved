### 地址
[Round](https://codeforces.com/contest/1328)

### A
给两个数a和b，可以对a进行+1操作，问最少多少次操作能够使得b是a的因子  
暴力

### B
有一个长度为n的字符串，只包含两个字符b，剩下的全为字符a，问第k个字典序大小的字符串是哪一个  
找规律

### C
有一个字符串只包含0，1，2，定义了一种新的**XOR**规则，及c = (a+b)%3  
给定一个很长的字符串c，求a**XOR**b == c并且min(max(a, b))  
从左往右扫，遇到2则拆成1和1，遇到0则是0和0，遇到第一个1，则将a的位置设为1，b的位置设为0，之后，a所有都为0，b和c的字符相同

### D
有n个卡片，每个卡片有一个数字代表动物，并且这个卡片组是首尾相连的，即一个环  
你需要给卡片上色，并且保证相邻的不同动物的卡片必需不同颜色，问最少的颜色数，并输出每个卡片的颜色  
显然若所有卡片都一样，则1就够了  
若有偶数张卡片，则1 2 1 2 ....就行了  
若奇数张需要分两种情况：  
- 有相邻的卡片是同动物的，则只要在这相邻的同动物卡片将颜色翻转一下，则变得和偶数张卡片一样了
- 无的话就1 2 1 2 1 2 ..... 3即可

### E
给定一棵树，有n个询问，询问如下：  
给出k个点，问是否存在一条从根开始的路径，使得这些点在这路径上或者离这条路径的距离为1  
显然该路径必须是根节点到这k个点中深度最大的那个节点的路径，若有的点离这条路径距离为1，等价于该点的父节点在这条路径上  
该问题等价于这k个点的父节点是否在同一路径下  
我们先用dfs记录下每个点的父节点，深度，已经第一次遍历到这个节点的时间(tin)和最后一次遍历到这个节点的时间(tout)  
若节点u是节点v的父亲，则tin[u]<=tin[v] && tout[v]<=tout[u]  
则判断一下这些节点的父节点是否都是深度最大的节点的父亲即可
